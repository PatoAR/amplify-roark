import { defineBackend } from '@aws-amplify/backend';
import { Stack, Duration, CfnOutput } from 'aws-cdk-lib';
import { Rule, Schedule } from 'aws-cdk-lib/aws-events';
import { LambdaFunction } from 'aws-cdk-lib/aws-events-targets';
import { Function as LambdaFunctionConstruct, FunctionUrl, FunctionUrlAuthType, HttpMethod } from 'aws-cdk-lib/aws-lambda';
import { PolicyStatement, Effect } from 'aws-cdk-lib/aws-iam';
import { createHash } from 'crypto';
import { auth } from './auth/resource';
import { data } from './data/resource';
import { referralProcessor } from './functions/referral-processor/resource';
import { subscriptionManager } from './functions/subscription-manager/resource';
import { sessionCleanup } from './functions/session-cleanup/resource';
import { sesCampaignSender } from './functions/ses-campaign-sender/resource';
import { sesBounceHandler } from './functions/ses-bounce-handler/resource';

export const backend = defineBackend({
  auth,
  data,
  referralProcessor,
  subscriptionManager,
  sessionCleanup,
  sesCampaignSender,
  sesBounceHandler,
});

// Add EventBridge schedule for session cleanup function
// Access the function resource from the backend
const sessionCleanupFunction = backend.sessionCleanup.resources.lambda;

// Get the stack that contains the function
const functionStack = Stack.of(sessionCleanupFunction);

// Create EventBridge rule that runs every hour
// Use stack name hash in rule name to make it unique per branch/environment
// This prevents conflicts when multiple branches deploy to the same AWS account
// EventBridge rule names are limited to 64 characters
const stackName = functionStack.stackName;
// Create a short hash of the stack name for uniqueness (8 chars is sufficient)
const stackHash = createHash('md5').update(stackName).digest('hex').substring(0, 8);
const ruleName = `session-cleanup-${stackHash}`; // Total: 28 chars, well under 64 limit
const scheduleRule = new Rule(functionStack, 'SessionCleanupSchedule', {
  ruleName: ruleName,
  description: 'Triggers session cleanup Lambda every hour to expire abandoned sessions',
  schedule: Schedule.rate(Duration.hours(1)), // Run every 1 hour
  enabled: true,
});

// Add Lambda function as target
scheduleRule.addTarget(new LambdaFunction(sessionCleanupFunction));

// Add EventBridge schedule for SES campaign sender function
const sesCampaignSenderFunction = backend.sesCampaignSender.resources.lambda;
const sesCampaignSenderStack = Stack.of(sesCampaignSenderFunction);
const sesCampaignSenderStackHash = createHash('md5').update(sesCampaignSenderStack.stackName).digest('hex').substring(0, 8);
const sesCampaignSenderRuleName = `ses-campaign-sender-${sesCampaignSenderStackHash}`;

// Set environment variables for table names from Amplify data resource
// Table names are dynamically generated by Amplify and follow pattern: ModelName-{hash}
const contactTable = backend.data.resources.tables['SESCampaignContact'];
const controlTable = backend.data.resources.tables['SESCampaignControl'];
const lambdaFunction = sesCampaignSenderFunction as LambdaFunctionConstruct;

// Add environment variables using CloudFormation references
// Amplify Gen 2 GSI naming convention: {modelName}sBy{FieldName}
// For SESCampaignContact model with index('Sent_Status'), the GSI name is: sESCampaignContactsBySent_Status
lambdaFunction.addEnvironment('CONTACT_TABLE_NAME', contactTable.tableName);
lambdaFunction.addEnvironment('CAMPAIGN_CONTROL_TABLE_NAME', controlTable.tableName);
lambdaFunction.addEnvironment('CONTACT_TABLE_GSI_NAME', 'sESCampaignContactsBySent_Status');

// Export table names as CloudFormation outputs for use by local scripts
// This enables scripts to discover the correct tables for the current branch/environment
const dataStack = backend.data.stack;
new CfnOutput(dataStack, 'SESCampaignContactTableName', {
  value: contactTable.tableName,
  description: 'DynamoDB table name for SES Campaign Contacts',
});
new CfnOutput(dataStack, 'SESCampaignControlTableName', {
  value: controlTable.tableName,
  description: 'DynamoDB table name for SES Campaign Control',
});

const sesCampaignSenderScheduleRule = new Rule(sesCampaignSenderStack, 'SESCampaignSenderSchedule', {
  ruleName: sesCampaignSenderRuleName,
  description: 'Triggers SES campaign sender Lambda hourly during business hours (10 AM - 4 PM Buenos Aires time, Monday-Friday)',
  schedule: Schedule.expression('cron(0 10-16 ? * MON-FRI *)'), // Every hour from 10 AM to 4 PM, Monday-Friday
  enabled: true,
});

// Add Lambda function as target
sesCampaignSenderScheduleRule.addTarget(new LambdaFunction(sesCampaignSenderFunction));

// Grant SES SendEmail permission to Lambda function
// Allow sending emails from the verified identity
sesCampaignSenderFunction.addToRolePolicy(
  new PolicyStatement({
    effect: Effect.ALLOW,
    actions: ['ses:SendEmail', 'ses:SendRawEmail'],
    resources: ['*'], // Can be restricted to specific identity ARN if needed
  })
);

// Grant DynamoDB permissions to Lambda function
// Allow reading campaign control and querying/updating contacts
sesCampaignSenderFunction.addToRolePolicy(
  new PolicyStatement({
    effect: Effect.ALLOW,
    actions: [
      'dynamodb:GetItem',
      'dynamodb:Query',
      'dynamodb:UpdateItem',
    ],
    resources: [
      contactTable.tableArn,
      `${contactTable.tableArn}/index/*`, // Allow access to all GSIs
      controlTable.tableArn,
    ],
  })
);

// Enable Function URL for test email endpoint
// Create Function URL in the same stack as the function (data stack)
// Use simplified CORS configuration
const functionUrl = new FunctionUrl(sesCampaignSenderStack, 'SESCampaignSenderFunctionUrl', {
  function: sesCampaignSenderFunction,
  authType: FunctionUrlAuthType.NONE, // Public access for test endpoint
});

// Configure SES Bounce Handler
const sesBounceHandlerFunction = backend.sesBounceHandler.resources.lambda;

// Grant DynamoDB permissions to bounce handler
// Allow updating ANY SESCampaignContact table (for multi-branch support)
sesBounceHandlerFunction.addToRolePolicy(
  new PolicyStatement({
    effect: Effect.ALLOW,
    actions: ['dynamodb:UpdateItem'],
    resources: [
      `arn:aws:dynamodb:${Stack.of(contactTable).region}:${Stack.of(contactTable).account}:table/SESCampaignContact*`
    ],
  })
);
